
# ./tailwind.config.js
export default {
    content: [
      "./index.html",
      "./src/**/*.{js,jsx,ts,tsx}",
    ],
    theme: {
      extend: {
        fontFamily: {
          sans: ['-apple-system', 'BlinkMacSystemFont', '"Segoe UI"', 'Roboto', 'Helvetica', 'Arial', 'sans-serif'],
        },
      },
    },
    plugins: [],
  };
  
# ./vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import tailwindcss from '@tailwindcss/vite';

// Electron typically serves from src as root
export default defineConfig({
  root: './src',
  base: './',
  plugins: [react(), tailwindcss()],
  build: {
    outDir: '../dist',
  },
});

# ./files.sh

echo "" > all_files.txt

find . \
  -type f \
  ! -path "*/node_modules/*" \
  ! -path "*/.git/*" \
  ! -path "*/package-lock.json" \
  ! -path "*/database.sqlite" \
  ! -path "*/all_files.txt" \
  ! -path "*/next_steps.txt" \
  ! -path "*/clipboard.txt" \
  | while read file; do
      echo "# ${file#/path/to/root/}"
      echo "# ${file#/path/to/root/}" >> all_files.txt
      cat "$file" >> all_files.txt
      echo "" >> all_files.txt
    done

# ./.gitignore
node_modules

# ./package.json
{
  "name": "document-organizer",
  "version": "0.0.1",
  "main": "electron/main.js",
  "type": "module",
  "scripts": {
    "dev:react": "vite",
    "dev:electron": "wait-on tcp:5173 && electron .",
    "start": "concurrently \"npm run dev:react\" \"npm run dev:electron\"",
    "postinstall": "electron-rebuild"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.7",
    "@heroicons/react": "^2.2.0",
    "better-sqlite3": "^9.6.0",
    "electron": "^29.0.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  },
  "devDependencies": {
    "@tailwindcss/cli": "^4.1.11",
    "@tailwindcss/postcss": "^4.1.11",
    "@tailwindcss/vite": "^4.1.11",
    "@vitejs/plugin-react": "^4.0.0",
    "autoprefixer": "^10.4.21",
    "concurrently": "^8.0.0",
    "electron-rebuild": "^3.2.9",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.11",
    "vite": "^5.0.0",
    "wait-on": "^7.0.0"
  }
}

# ./electron/preload.js
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electron', {
  invoke: (channel, data) => ipcRenderer.invoke(channel, data),
  on: (channel, func) => ipcRenderer.on(channel, (event, ...args) => func(...args)),
  removeAllListeners: (channel) => ipcRenderer.removeAllListeners(channel)
});
# ./electron/db.js
// electron/db.js
import Database from 'better-sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const dbPath = path.join(__dirname, '..', 'database.sqlite');
const db = new Database(dbPath);

// Create table with new columns for phase 3
db.prepare(`
  CREATE TABLE IF NOT EXISTS documents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    path TEXT UNIQUE,
    size INTEGER,
    lastModified TEXT,
    category TEXT DEFAULT '',
    tags TEXT DEFAULT ''
  )
`).run();

// Migration in case old DB exists
try {
  db.prepare('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT ""').run();
} catch {}
try {
  db.prepare('ALTER TABLE documents ADD COLUMN tags TEXT DEFAULT ""').run();
} catch {}

db.prepare('CREATE INDEX IF NOT EXISTS idx_documents_path ON documents(path)').run();
db.prepare('CREATE INDEX IF NOT EXISTS idx_documents_lastModified ON documents(lastModified)').run();

export default db;

# ./electron/main.js
import { app, BrowserWindow, ipcMain, dialog, shell } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import db from './db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 900,
    height: 650,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  mainWindow.loadURL('http://localhost:5173');
}

// Utility: File metadata
function getFileMetadata(filePath) {
  try {
    const stats = fs.statSync(filePath);
    return { size: stats.size, lastModified: stats.mtime.toISOString() };
  } catch {
    return { size: null, lastModified: null };
  }
}

// Utility: Recursive directory scan
function getAllFiles(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files = files.concat(getAllFiles(fullPath));
    } else {
      files.push(fullPath);
    }
  }
  return files;
}

app.whenReady().then(() => {
  createWindow();
});

//
// IPC HANDLERS
//

// Fetch all documents
ipcMain.handle('get-documents', async () => {
  return db.prepare('SELECT * FROM documents').all();
});

// Update category/tags
ipcMain.handle('update-document', async (_, { id, category, tags }) => {
  if (category !== undefined) {
    db.prepare('UPDATE documents SET category = ? WHERE id = ?').run(category, id);
  }
  if (tags !== undefined) {
    db.prepare('UPDATE documents SET tags = ? WHERE id = ?').run(tags, id);
  }
  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
});

ipcMain.handle('delete-document', (event, docId) => {
  db.prepare('DELETE FROM documents WHERE id = ?').run(docId);
  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return true;
});

ipcMain.handle('pick-and-add-document', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({ properties: ['openFile'] });
  if (canceled || filePaths.length === 0) return null;

  const filePath = filePaths[0];
  const fileName = path.basename(filePath);

  // Prevent duplicates
  const exists = db.prepare('SELECT 1 FROM documents WHERE path = ?').get(filePath);
  if (exists) return { duplicate: true, name: fileName, path: filePath };

  const meta = getFileMetadata(filePath);
  db.prepare('INSERT INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)')
    .run(fileName, filePath, meta.size, meta.lastModified);

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs[updatedDocs.length - 1];
});

ipcMain.handle('pick-directory', async () => {
  const result = await dialog.showOpenDialog({ properties: ['openDirectory'] });
  if (result.canceled || result.filePaths.length === 0) return;

  const dirPath = result.filePaths[0];
  const filePaths = getAllFiles(dirPath);

  const insert = db.prepare(
    'INSERT OR IGNORE INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)'
  );
  for (const filePath of filePaths) {
    const meta = getFileMetadata(filePath);
    insert.run(path.basename(filePath), filePath, meta.size, meta.lastModified);
  }

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs;
});

// Drag & drop handler
ipcMain.handle('add-dropped-files', (event, filePaths) => {
  const insert = db.prepare(
    'INSERT OR IGNORE INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)'
  );

  function processPath(p) {
    const stats = fs.statSync(p);
    if (stats.isDirectory()) {
      const entries = fs.readdirSync(p);
      for (const entry of entries) {
        processPath(path.join(p, entry));
      }
    } else {
      const meta = getFileMetadata(p);
      insert.run(path.basename(p), p, meta.size, meta.lastModified);
    }
  }

  filePaths.forEach(processPath);

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs;
});


ipcMain.handle('show-in-finder', (_, filePath) => shell.showItemInFolder(filePath));
ipcMain.handle('open-file', async (_, filePath) => shell.openPath(filePath));

ipcMain.handle('check-missing-files', () => {
  const docs = db.prepare('SELECT * FROM documents').all();
  const missing = [];

  for (const doc of docs) {
    if (!fs.existsSync(doc.path)) {
      missing.push(doc.id);
    }
  }

  if (missing.length > 0) {
    db.prepare(`DELETE FROM documents WHERE id IN (${missing.join(',')})`).run();
  }

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);

  return missing.length;
});

// Update tags/category
ipcMain.handle('update-doc-metadata', (event, { id, category, tags }) => {
  db.prepare('UPDATE documents SET category=?, tags=? WHERE id=?').run(category, tags, id);
  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return true;
});

// Export DB
ipcMain.handle('export-db', async () => {
  const { filePath } = await dialog.showSaveDialog({
    title: 'Export Database',
    defaultPath: 'documents-backup.sqlite',
    filters: [{ name: 'SQLite DB', extensions: ['sqlite'] }]
  });

  if (!filePath) return false;
  fs.copyFileSync(path.join(__dirname, '..', 'database.sqlite'), filePath);
  return true;
});

// Import DB
ipcMain.handle('import-db', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [{ name: 'SQLite DB', extensions: ['sqlite'] }]
  });

  if (canceled || filePaths.length === 0) return false;

  const importPath = filePaths[0];
  fs.copyFileSync(importPath, path.join(__dirname, '..', 'database.sqlite'));

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return true;
});


ipcMain.handle('file-exists', (_, filePath) => {
  const fs = require('fs');
  return fs.existsSync(filePath);
});
# ./postcss.config.js
export default {
    plugins: {
      '@tailwindcss/postcss': {},
      autoprefixer: {},
    },
  };
  
# ./src/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document Organizer</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/main.jsx"></script>
</body>
</html>

# ./src/index.css
@import "tailwindcss";

html, body, #root {
height: 100%;
margin: 0;
font-family: 'Roboto', sans-serif;
background-color: #f5f7fa;
}

h1 {
margin-bottom: 20px;
}

button {
cursor: pointer;
}

.MuiTable-root th {
background-color: #f0f2f5;
font-weight: bold;
}

.MuiTableRow-root:hover {
background-color: #f9fafb;
}

.drag-over {
border: 2px dashed #736efe;
background-color: rgba(115, 110, 254, 0.05);

pointer-events: none;
}
.drag-over * {
pointer-events: auto;
}

.chip-container {
display: flex;
flex-wrap: wrap;
gap: 4px;
}

.chip-container .MuiChip-root {
margin: 2px;
}

.add-tag-input {
width: 80px;
margin-top: 2px;
}

.action-buttons button {
min-width: 30px;
margin-right: 2px;
}


# ./src/components/DocumentsTable.jsx
import React, { useState, useEffect } from 'react';
import { XMarkIcon } from '@heroicons/react/24/solid';

const CATEGORY_OPTIONS = ['Work', 'Personal', 'Finance', 'Legal', 'Health', 'Other'];

export default function DocumentsTable() {
  const [documents, setDocuments] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');

  const refreshDocuments = async () => {
    const docs = await window.electron.invoke('get-documents');
    // Mark missing files
    const checked = await Promise.all(
      docs.map(async (doc) => {
        const exists = await window.electron.invoke('file-exists', doc.path);
        return { ...doc, missing: !exists };
      })
    );
    setDocuments(checked);
  };

  useEffect(() => {
    refreshDocuments();
    const listener = () => refreshDocuments();
    window.electron.on('documents-updated', listener);
    return () => {};
  }, []);

  const updateDocument = (id, data) => {
    window.electron.invoke('update-document', { id, ...data });
  };

  const deleteDocument = (id) => {
    if (confirm('Are you sure you want to delete this document from the database?')) {
      window.electron.invoke('delete-document', id);
    }
  };

  const viewFile = (filePath) => window.electron.invoke('open-file', filePath);
  const showInFinder = (filePath) => window.electron.invoke('show-in-finder', filePath);

  const handleTagAdd = (doc, e) => {
    if (e.key === 'Enter' && e.target.value.trim() !== '') {
      const newTags = doc.tags ? doc.tags.split(',').map(t => t.trim()) : [];
      newTags.push(e.target.value.trim());
      const tagStr = newTags.join(', ');
      updateDocument(doc.id, { tags: tagStr });
      e.target.value = '';
    }
  };

  const handleTagRemove = (doc, tag) => {
    const newTags = doc.tags
      .split(',')
      .map(t => t.trim())
      .filter(t => t !== tag)
      .join(', ');
    updateDocument(doc.id, { tags: newTags });
  };

  const filteredDocs = documents.filter(doc => {
    const query = searchQuery.toLowerCase();
    return (
      (doc.name || '').toLowerCase().includes(query) ||
      (doc.path || '').toLowerCase().includes(query) ||
      (doc.category || '').toLowerCase().includes(query) ||
      (doc.tags || '').toLowerCase().includes(query)
    );
  });

  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-semibold text-gray-800 mb-2">Your Documents</h2>

      <input
        type="text"
        placeholder="Search by name, path, category, or tags..."
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        className="w-full p-3 border rounded-full shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400"
      />

      <div className="overflow-x-auto rounded-2xl shadow-sm border border-gray-200">
        <table className="min-w-full border-collapse overflow-hidden rounded-2xl">
          <thead className="bg-gray-50 text-gray-700 text-sm">
            <tr>
              <th className="p-3 text-left">File Name</th>
              <th className="p-3 text-left">Path</th>
              <th className="p-3 text-left">Category</th>
              <th className="p-3 text-left">Tags</th>
              <th className="p-3 text-center">Missing?</th>
              <th className="p-3 text-center">Actions</th>
            </tr>
          </thead>
          <tbody>
            {filteredDocs.map((doc, idx) => (
              <tr
                key={doc.id}
                className={`border-t border-gray-100 hover:bg-gray-50 transition ${
                  idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'
                } ${doc.missing ? 'bg-red-50' : ''}`}
              >
                <td className="p-3 font-medium text-gray-800">{doc.name}</td>
                <td className="p-3 text-xs text-gray-500">{doc.path}</td>
                <td className="p-3">
                  <select
                    defaultValue={doc.category || 'Other'}
                    onChange={(e) => updateDocument(doc.id, { category: e.target.value })}
                    className="w-full border rounded-full p-1 px-2 text-sm shadow-sm bg-white focus:outline-none focus:ring-1 focus:ring-blue-400"
                  >
                    {CATEGORY_OPTIONS.map(cat => (
                      <option key={cat} value={cat}>{cat}</option>
                    ))}
                  </select>
                </td>
                <td className="p-3">
                  <div className="flex flex-wrap gap-1 mb-1">
                    {doc.tags && doc.tags.split(',').map(tag => (
                      <span
                        key={tag}
                        className="flex items-center bg-gradient-to-r from-blue-100 to-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs shadow-sm hover:shadow transition"
                      >
                        {tag}
                        <XMarkIcon
                          className="w-4 h-4 ml-1 cursor-pointer hover:text-red-500 transition-transform hover:scale-110"
                          onClick={() => handleTagRemove(doc, tag)}
                        />
                      </span>
                    ))}
                  </div>
                  <input
                    type="text"
                    placeholder="Add tag..."
                    onKeyDown={(e) => handleTagAdd(doc, e)}
                    className="w-full border rounded-full p-1 px-2 text-xs shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-400"
                  />
                </td>
                <td className="p-3 text-center font-semibold">
                  {doc.missing ? '‚ö†Ô∏è Missing' : 'No'}
                </td>
                <td className="p-3 text-center space-x-2">
                  <button onClick={() => viewFile(doc.path)} className="px-2 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600">View</button>
                  <button onClick={() => showInFinder(doc.path)} className="px-2 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600">Finder</button>
                  <button onClick={() => deleteDocument(doc.id)} className="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600">Delete</button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}

# ./src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';


ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

# ./src/App.jsx
import { useEffect } from 'react';
import DocumentsTable from './components/DocumentsTable.jsx';

function App() {

  const addDocumentFromFile = async () => {
    const newDoc = await window.electron.invoke('pick-and-add-document');
    if (!newDoc) return;
    if (newDoc.duplicate) alert(`‚ö† ${newDoc.name} is already in the database.`);
  };

  const pickDirectory = async () => {
    await window.electron.invoke('pick-directory');
  };

  const checkMissingFiles = async () => {
    const removedCount = await window.electron.invoke('check-missing-files');
    alert(`Removed ${removedCount} missing files from database.`);
  };

  const exportDB = () => window.electron.invoke('export-db');
  const importDB = () => window.electron.invoke('import-db');

  const handleDrop = async (e) => {
    e.preventDefault();
    const files = [...e.dataTransfer.files].map(f => f.path);
    await window.electron.invoke('add-dropped-files', files);
  };

  return (
    <div
      className="min-h-screen bg-gray-100 flex justify-center p-6 font-sans"
      onDrop={handleDrop}
      onDragOver={(e) => e.preventDefault()}
    >
      <div className="w-full max-w-7xl space-y-6">

        {/* Header */}
        <div className="bg-white shadow-md rounded-2xl p-8 flex flex-col items-center">
          <h1 className="text-4xl font-semibold text-gray-800 mb-1 flex items-center gap-2">
            üìÇ Document Organizer
          </h1>
          <p className="text-gray-500 text-sm">Organize, tag, and manage your files effortlessly</p>
        </div>

        {/* Action Buttons */}
        <div className="bg-white shadow rounded-xl p-4 flex flex-wrap justify-center gap-3">
          <button onClick={addDocumentFromFile} className="px-4 py-2 bg-blue-500 text-white rounded-full shadow hover:bg-blue-600 transition">
            üìÑ Add File
          </button>
          <button onClick={pickDirectory} className="px-4 py-2 bg-green-500 text-white rounded-full shadow hover:bg-green-600 transition">
            üìÅ Add Directory
          </button>
          <button onClick={checkMissingFiles} className="px-4 py-2 bg-yellow-400 text-white rounded-full shadow hover:bg-yellow-500 transition">
            üßπ Remove Missing Files
          </button>
          <button onClick={exportDB} className="px-4 py-2 bg-indigo-500 text-white rounded-full shadow hover:bg-indigo-600 transition">
            üíæ Export DB
          </button>
          <button onClick={importDB} className="px-4 py-2 bg-purple-500 text-white rounded-full shadow hover:bg-purple-600 transition">
            üì• Import DB
          </button>
        </div>

        {/* Table */}
        <div className="bg-white shadow-lg rounded-2xl p-6">
          <DocumentsTable />
        </div>
      </div>
    </div>
  );
}

export default App;

