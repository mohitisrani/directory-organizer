
# ./tailwind.config.js
export default {
    content: [
      "./index.html",
      "./src/**/*.{js,jsx,ts,tsx}",
    ],
    theme: {
      extend: {
        fontFamily: {
          sans: ['-apple-system', 'BlinkMacSystemFont', '"Segoe UI"', 'Roboto', 'Helvetica', 'Arial', 'sans-serif'],
        },
      },
    },
    plugins: [],
  };
  
# ./vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import tailwindcss from '@tailwindcss/vite';

// Electron typically serves from src as root
export default defineConfig({
  root: './src',
  base: './',
  plugins: [react(), tailwindcss()],
  build: {
    outDir: '../dist',
  },
});

# ./files.sh

echo "" > all_files.txt

find . \
  -type f \
  ! -path "*/node_modules/*" \
  ! -path "*/.git/*" \
  ! -path "*/test/*" \
  ! -path "*/package-lock.json" \
  ! -path "*/database.sqlite" \
  ! -path "*/all_files.txt" \
  ! -path "*/next_steps.txt" \
  ! -path "*/clipboard.txt" \
  ! -path "*/.gitignore" \
  ! -path "*/eng.traineddata" \
  | while read file; do
      echo "# ${file#/path/to/root/}"
      echo "# ${file#/path/to/root/}" >> all_files.txt
      cat "$file" >> all_files.txt
      echo "" >> all_files.txt
    done

# ./package.json
{
  "name": "document-organizer",
  "version": "0.0.1",
  "main": "electron/main.js",
  "type": "module",
  "scripts": {
    "dev:react": "vite",
    "dev:electron": "wait-on tcp:5173 && electron .",
    "start": "concurrently \"npm run dev:react\" \"npm run dev:electron\"",
    "postinstall": "electron-rebuild",
    "migrate:chunks": "node electron/migrate_chunks.js"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.7",
    "@heroicons/react": "^2.2.0",
    "@xenova/transformers": "^2.17.2",
    "better-sqlite3": "^9.6.0",
    "electron": "^29.0.0",
    "mammoth": "^1.10.0",
    "openai": "^5.11.0",
    "pdf-lib": "^1.17.1",
    "pdf-parse": "^1.1.1",
    "pdf-poppler": "^0.2.1",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "sqlite": "^5.1.1",
    "tesseract.js": "^6.0.1"
  },
  "devDependencies": {
    "@tailwindcss/cli": "^4.1.11",
    "@tailwindcss/postcss": "^4.1.11",
    "@tailwindcss/vite": "^4.1.11",
    "@vitejs/plugin-react": "^4.0.0",
    "autoprefixer": "^10.4.21",
    "concurrently": "^8.0.0",
    "electron-rebuild": "^3.2.9",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.11",
    "vite": "^5.0.0",
    "wait-on": "^7.0.0"
  }
}

# ./electron/preload.js
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electron', {
  invoke: (channel, data) => ipcRenderer.invoke(channel, data),
  on: (channel, func) => ipcRenderer.on(channel, (event, ...args) => func(...args)),
  removeAllListeners: (channel) => ipcRenderer.removeAllListeners(channel)
});
# ./electron/migrate_chunks.js
// electron/migrate_chunks.js
import db from './db.js';
import fs from 'fs';
import path from 'path';
import { pipeline } from '@xenova/transformers';
import pdf from 'pdf-parse';
import Tesseract from 'tesseract.js';
import { execSync } from 'child_process';

// ------------------ DB MIGRATION ------------------
db.prepare(`
  CREATE TABLE IF NOT EXISTS document_chunks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    document_id INTEGER,
    chunk_index INTEGER,
    content TEXT,
    embedding TEXT,
    FOREIGN KEY(document_id) REFERENCES documents(id)
  )
`).run();

db.prepare('CREATE INDEX IF NOT EXISTS idx_chunks_docid ON document_chunks(document_id)').run();

console.log('‚úÖ document_chunks table ensured.');

// ------------------ EMBEDDING UTILITIES ------------------

async function getEmbedder() {
  if (!global.embedder) {
    global.embedder = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
  }
  return global.embedder;
}

function chunkText(text, chunkSize = 1000, overlap = 100) {
  const chunks = [];
  let start = 0;
  while (start < text.length) {
    const end = Math.min(start + chunkSize, text.length);
    chunks.push(text.slice(start, end));
    start += chunkSize - overlap;
  }
  return chunks;
}

async function extractText(filePath) {
  const ext = path.extname(filePath).toLowerCase();

  if (!fs.existsSync(filePath)) return '';

  // Simple text formats
  if (['.txt', '.md', '.csv', '.json', '.log'].includes(ext)) {
    return fs.readFileSync(filePath, 'utf-8').slice(0, 50000);
  }

  // PDF parsing
  if (ext === '.pdf') {
    const dataBuffer = fs.readFileSync(filePath);
    const pdfData = await pdf(dataBuffer);
    let text = (pdfData.text || '').trim();

    // Fallback to OCR if minimal text
    if (text.length < 50) {
      console.log('‚ö° OCR fallback for:', filePath);
      const tempDir = path.join(process.cwd(), 'ocr-temp');
      if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);

      execSync(`pdftoppm "${filePath}" "${tempDir}/page" -png`);
      const pngFiles = fs.readdirSync(tempDir).filter(f => f.endsWith('.png'));
      for (const pngFile of pngFiles) {
        const imgPath = path.join(tempDir, pngFile);
        const { data: { text: ocrText } } = await Tesseract.recognize(imgPath, 'eng');
        text += '\n' + ocrText;
        fs.unlinkSync(imgPath);
      }
    }

    return text.slice(0, 50000);
  }

  return '';
}

async function generateEmbedding(text) {
  const embedder = await getEmbedder();
  const output = await embedder(text, { pooling: 'mean', normalize: true });
  return Array.from(output.data);
}

// ------------------ MIGRATION PROCESS ------------------

async function migrateAllDocuments() {
  const docs = db.prepare('SELECT * FROM documents').all();
  console.log(`üìÑ Found ${docs.length} documents to migrate...`);

  for (const doc of docs) {
    // Skip if already chunked
    const chunkExists = db.prepare(
      'SELECT 1 FROM document_chunks WHERE document_id=? LIMIT 1'
    ).get(doc.id);
    if (chunkExists) {
      console.log(`‚è© Skipping ${doc.name}, chunks already exist.`);
      continue;
    }

    const text = await extractText(doc.path);
    if (!text.trim()) {
      console.warn(`‚ö†Ô∏è Skipping ${doc.name}, no text extracted.`);
      continue;
    }

    const chunks = chunkText(text, 1000, 100);
    console.log(`üìë ${doc.name} ‚Üí ${chunks.length} chunks`);

    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      const embedding = await generateEmbedding(chunk);

      db.prepare(`
        INSERT INTO document_chunks (document_id, chunk_index, content, embedding)
        VALUES (?, ?, ?, ?)
      `).run(doc.id, i, chunk, JSON.stringify(embedding));
    }

    console.log(`‚úÖ Migrated ${doc.name}`);
  }

  console.log('üéâ Migration complete! All documents now have chunked embeddings.');
}

migrateAllDocuments().then(() => process.exit(0));

# ./electron/db.js
// electron/db.js
import Database from 'better-sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';
import pdf from 'pdf-parse';
import { pipeline } from '@xenova/transformers';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const dbPath = path.join(__dirname, '..', 'database.sqlite');
const db = new Database(dbPath);

// Create table with new columns for phase 3
db.prepare(`
  CREATE TABLE IF NOT EXISTS documents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    path TEXT UNIQUE,
    size INTEGER,
    lastModified TEXT,
    category TEXT DEFAULT '',
    tags TEXT DEFAULT '',
    embedding TEXT DEFAULT NULL  -- store JSON array of embedding
  )
`).run();

try { db.prepare('ALTER TABLE documents ADD COLUMN embedding TEXT DEFAULT NULL').run(); } catch {}


// Migration in case old DB exists
try {
  db.prepare('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT ""').run();
} catch {}
try {
  db.prepare('ALTER TABLE documents ADD COLUMN tags TEXT DEFAULT ""').run();
} catch {}

db.prepare('CREATE INDEX IF NOT EXISTS idx_documents_path ON documents(path)').run();
db.prepare('CREATE INDEX IF NOT EXISTS idx_documents_lastModified ON documents(lastModified)').run();

db.prepare(`
  -- 1. Collections Table
  CREATE TABLE IF NOT EXISTS collections (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      description TEXT DEFAULT '',
      color TEXT DEFAULT NULL,
      createdAt TEXT DEFAULT CURRENT_TIMESTAMP
  );
`).run();

db.prepare(`-- 2. Relationship Table (Many-to-Many)
  CREATE TABLE IF NOT EXISTS collection_documents (
      collection_id INTEGER,
      document_id INTEGER,
      PRIMARY KEY (collection_id, document_id),
      FOREIGN KEY (collection_id) REFERENCES collections(id),
      FOREIGN KEY (document_id) REFERENCES documents(id)
  );
`).run();

export default db;

# ./electron/main.js
import { app, BrowserWindow, ipcMain, dialog, shell } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import db from './db.js';
import { pipeline } from '@xenova/transformers';
import pdf from 'pdf-parse'; // ‚úÖ Needed for extractText()

import { PDFDocument } from 'pdf-lib';
import Tesseract from 'tesseract.js';

import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 900,
    height: 650,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  mainWindow.loadURL('http://localhost:5173');
}

// Utility: File metadata
function getFileMetadata(filePath) {
  try {
    const stats = fs.statSync(filePath);
    return { size: stats.size, lastModified: stats.mtime.toISOString() };
  } catch {
    return { size: null, lastModified: null };
  }
}

// Utility: Recursive directory scan
function getAllFiles(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files = files.concat(getAllFiles(fullPath));
    } else {
      files.push(fullPath);
    }
  }
  return files;
}

app.whenReady().then(() => {
  createWindow();
});

//
// IPC HANDLERS
//

// Fetch all documents
ipcMain.handle('get-documents', async () => {
  return db.prepare('SELECT * FROM documents').all();
});

// Update category/tags
ipcMain.handle('update-document', async (_, { id, category, tags }) => {
  if (category !== undefined) {
    db.prepare('UPDATE documents SET category = ? WHERE id = ?').run(category, id);
  }
  if (tags !== undefined) {
    db.prepare('UPDATE documents SET tags = ? WHERE id = ?').run(tags, id);
  }
  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
});

// Safe delete-document handler with chunk cleanup
ipcMain.handle('delete-document', (event, docIds) => {
  // Support both single ID and array of IDs
  const ids = Array.isArray(docIds) ? docIds : [docIds];

  const deleteChunks = db.prepare('DELETE FROM document_chunks WHERE document_id = ?');
  const deleteDoc = db.prepare('DELETE FROM documents WHERE id = ?');

  const transaction = db.transaction((idsToDelete) => {
    for (const id of idsToDelete) {
      // Delete chunks first to avoid FK errors
      deleteChunks.run(id);
      deleteDoc.run(id);
    }
  });

  transaction(ids);

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);

  return true;
});


ipcMain.handle('pick-and-add-documents', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    properties: ['openFile', 'multiSelections']
  });

  if (canceled || filePaths.length === 0) return null;

  const insert = db.prepare(
    'INSERT OR IGNORE INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)'
  );

  const newDocs = [];

  for (const filePath of filePaths) {
    const fileName = path.basename(filePath);

    // Skip duplicates
    const exists = db.prepare('SELECT 1 FROM documents WHERE path = ?').get(filePath);
    if (exists) continue;

    const meta = getFileMetadata(filePath);
    insert.run(fileName, filePath, meta.size, meta.lastModified);

    const doc = db.prepare('SELECT * FROM documents WHERE path = ?').get(filePath);
    newDocs.push(doc);
  }

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return newDocs;
});


ipcMain.handle('pick-directory', async () => {
  const result = await dialog.showOpenDialog({ properties: ['openDirectory'] });
  if (result.canceled || result.filePaths.length === 0) return;

  const dirPath = result.filePaths[0];
  const filePaths = getAllFiles(dirPath);

  const insert = db.prepare(
    'INSERT OR IGNORE INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)'
  );
  for (const filePath of filePaths) {
    const meta = getFileMetadata(filePath);
    insert.run(path.basename(filePath), filePath, meta.size, meta.lastModified);
  }

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs;
});

// Drag & drop handler
ipcMain.handle('add-dropped-files', (event, filePaths) => {
  const insert = db.prepare(
    'INSERT OR IGNORE INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)'
  );

  function processPath(p) {
    const stats = fs.statSync(p);
    if (stats.isDirectory()) {
      const entries = fs.readdirSync(p);
      for (const entry of entries) {
        processPath(path.join(p, entry));
      }
    } else {
      const meta = getFileMetadata(p);
      insert.run(path.basename(p), p, meta.size, meta.lastModified);
    }
  }

  filePaths.forEach(processPath);

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs;
});


ipcMain.handle('show-in-finder', (_, filePath) => shell.showItemInFolder(filePath));
ipcMain.handle('open-file', async (_, filePath) => shell.openPath(filePath));

ipcMain.handle('check-missing-files', () => {
  const docs = db.prepare('SELECT * FROM documents').all();
  const missing = [];

  for (const doc of docs) {
    if (!fs.existsSync(doc.path)) {
      missing.push(doc.id);
    }
  }

  if (missing.length > 0) {
    db.prepare(`DELETE FROM documents WHERE id IN (${missing.join(',')})`).run();
  }

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);

  return missing.length;
});

// Update tags/category
ipcMain.handle('update-doc-metadata', (event, { id, category, tags }) => {
  db.prepare('UPDATE documents SET category=?, tags=? WHERE id=?').run(category, tags, id);
  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return true;
});

// Export DB
ipcMain.handle('export-db', async () => {
  const { filePath } = await dialog.showSaveDialog({
    title: 'Export Database',
    defaultPath: 'documents-backup.sqlite',
    filters: [{ name: 'SQLite DB', extensions: ['sqlite'] }]
  });

  if (!filePath) return false;
  fs.copyFileSync(path.join(__dirname, '..', 'database.sqlite'), filePath);
  return true;
});

// Import DB
ipcMain.handle('import-db', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [{ name: 'SQLite DB', extensions: ['sqlite'] }]
  });

  if (canceled || filePaths.length === 0) return false;

  const importPath = filePaths[0];
  fs.copyFileSync(importPath, path.join(__dirname, '..', 'database.sqlite'));

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return true;
});


ipcMain.handle('file-exists', (_, filePath) => {
  return fs.existsSync(filePath);
});

ipcMain.handle('read-file-content', async (_, filePath) => {
  try {
    const ext = path.extname(filePath).toLowerCase();

    // --- TEXT ---
    if (['.txt', '.md', '.json', '.log', '.csv'].includes(ext)) {
      const data = fs.readFileSync(filePath, 'utf-8');
      return { type: 'text', content: data.slice(0, 5000) };
    }

    // --- IMAGE as Base64 ---
    if (['.jpg', '.jpeg', '.png', '.gif'].includes(ext)) {
      const data = fs.readFileSync(filePath);
      const base64 = `data:image/${ext.replace('.', '')};base64,${data.toString('base64')}`;
      return { type: 'image', content: base64 };
    }

    // --- PDF as Base64 ---
    if (ext === '.pdf') {
      const data = fs.readFileSync(filePath);
      const base64 = `data:application/pdf;base64,${data.toString('base64')}`;
      return { type: 'pdf', content: base64 };
    }

    return { type: 'unsupported', content: null };
  } catch (err) {
    console.error('Error reading file for preview:', err);
    return { type: 'error', content: null };
  }
});

let embedder = null;
async function getEmbedder() {
  if (!embedder) {
    embedder = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
  }
  return embedder;
}


// -------------------- TEXT EXTRACTION & EMBEDDINGS --------------------

async function extractText(filePath) {
  try {
    if (!fs.existsSync(filePath)) {
      console.warn('‚ö†Ô∏è File not found, skipping embedding:', filePath);
      return '';
    }

    const ext = path.extname(filePath).toLowerCase();

    // 1. Text-based files
    if (['.txt', '.md', '.csv', '.json', '.log'].includes(ext)) {
      return fs.readFileSync(filePath, 'utf-8').slice(0, 20000);
    }

    // 2. PDF: Try pdf-parse first
    if (ext === '.pdf') {
      const absPath = path.resolve(filePath);
      const dataBuffer = fs.readFileSync(absPath);
      const pdfData = await pdf(dataBuffer);

      let extractedText = (pdfData.text || '').trim();

      // 3. Fallback to OCR if very little text
      if (extractedText.length < 50) {
        console.log('‚ö° Running OCR on PDF images:', filePath);
        const tempDir = path.join(__dirname, 'ocr-temp');
        if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);

        // Convert PDF to PNG images using poppler
        execSync(`pdftoppm "${absPath}" "${tempDir}/page" -png`);

        // Process each page
        const pngFiles = fs.readdirSync(tempDir).filter(f => f.endsWith('.png'));
        for (const pngFile of pngFiles) {
          console.log('üñº OCR processing:', pngFile);
          const imgPath = path.join(tempDir, pngFile);
          const { data: { text } } = await Tesseract.recognize(imgPath, 'eng');
          extractedText += '\n' + text;
          fs.unlinkSync(imgPath); // cleanup page image
        }
      }

      return extractedText.slice(0, 20000);
    }

    return '';
  } catch (err) {
    console.error('‚ùå OCR/Text extraction failed for', filePath, err);
    return '';
  }
}

// Generate embedding
async function generateEmbedding(text) {
  if (!text || !text.trim()) return null;
  const model = await getEmbedder();
  const output = await model(text, { pooling: 'mean', normalize: true });
  return Array.from(output.data); // Float32Array ‚Üí JS Array
}

// Generate embedding for one document
function chunkText(text, chunkSize = 1000, overlap = 100) {
  const chunks = [];
  let start = 0;
  while (start < text.length) {
    const end = Math.min(start + chunkSize, text.length);
    chunks.push(text.slice(start, end));
    start += chunkSize - overlap;
  }
  return chunks;
}

ipcMain.handle('generate-document-embedding', async (_, docId) => {
  const doc = db.prepare('SELECT * FROM documents WHERE id = ?').get(docId);
  if (!doc) return null;

  const text = await extractText(doc.path);
  if (!text.trim()) {
    console.warn('‚ö†Ô∏è No text extracted for embedding:', doc.path);
    return null;
  }

  const chunks = chunkText(text, 1000, 100); // ~1k chars with 100 overlap
  const model = await getEmbedder();
  let totalEmbeddings = 0;

  // Remove old chunks if regenerating
  db.prepare('DELETE FROM document_chunks WHERE document_id=?').run(docId);

  for (let i = 0; i < chunks.length; i++) {
    const chunk = chunks[i];
    const output = await model(chunk, { pooling: 'mean', normalize: true });
    const embedding = Array.from(output.data);

    db.prepare(`
      INSERT INTO document_chunks (document_id, chunk_index, content, embedding)
      VALUES (?, ?, ?, ?)
    `).run(docId, i, chunk, JSON.stringify(embedding));

    totalEmbeddings++;
  }

  console.log(`‚úÖ Generated ${totalEmbeddings} chunk embeddings for ${doc.name}`);

  // Keep doc.embedding as NULL for now to not break existing logic
  return totalEmbeddings;
});



// Cosine similarity
function cosineSimilarity(vecA, vecB) {
  let dot = 0, normA = 0, normB = 0;
  for (let i = 0; i < vecA.length; i++) {
    dot += vecA[i] * vecB[i];
    normA += vecA[i] * vecA[i];
    normB += vecB[i] * vecB[i];
  }
  return dot / (Math.sqrt(normA) * Math.sqrt(normB));
}

// Semantic search IPC
ipcMain.handle('semantic-search', async (_, query, topK = 5) => {
  console.log(`üîç Semantic search started for query: "${query}"`);

  const qEmbed = await generateEmbedding(query);
  if (!qEmbed) return [];

  const chunks = db.prepare('SELECT * FROM document_chunks').all();
  if (chunks.length === 0) {
    console.warn('‚ö†Ô∏è No chunk embeddings found.');
    return [];
  }

  // Score all chunks
  const scoredChunks = chunks.map(chunk => {
    const embedding = JSON.parse(chunk.embedding);
    const score = cosineSimilarity(qEmbed, embedding);
    return { ...chunk, score };
  });

  // Group by document and keep only top chunk per doc
  const bestChunksByDoc = {};
  for (const chunk of scoredChunks) {
    const docId = chunk.document_id;
    if (!bestChunksByDoc[docId] || bestChunksByDoc[docId].score < chunk.score) {
      bestChunksByDoc[docId] = chunk;
    }
  }

  // Convert to array and sort by score
  const topDocs = Object.values(bestChunksByDoc)
    .sort((a, b) => b.score - a.score)
    .slice(0, topK)
    .map(chunk => {
      const doc = db.prepare('SELECT * FROM documents WHERE id=?').get(chunk.document_id);
      return {
        ...doc,
        score: chunk.score,
        snippet: chunk.content.slice(0, 200) + (chunk.content.length > 200 ? '...' : '')
      };
    });

  console.log(`‚úÖ Top ${topK} semantic results for "${query}":`);
  topDocs.forEach((res, i) => console.log(` ${i + 1}. ${res.name} ‚Üí ${res.score.toFixed(4)}`));

  return topDocs;
});

// ---- Collections CRUD ----
ipcMain.handle('get-collections', () => {
  return db.prepare('SELECT * FROM collections ORDER BY createdAt DESC').all();
});

ipcMain.handle('create-collection', (_, { name, description = '', color = null }) => {
  const stmt = db.prepare('INSERT INTO collections (name, description, color) VALUES (?, ?, ?)');
  const info = stmt.run(name, description, color);
  return { id: info.lastInsertRowid, name, description, color };
});

ipcMain.handle('delete-collection', (_, collectionId) => {
  db.prepare('DELETE FROM collection_documents WHERE collection_id=?').run(collectionId);
  db.prepare('DELETE FROM collections WHERE id=?').run(collectionId);
  return true;
});

// ---- Collection Documents ----
ipcMain.handle('get-collection-docs', (_, collectionId) => {
  return db.prepare(`
    SELECT d.*
    FROM documents d
    JOIN collection_documents cd ON d.id = cd.document_id
    WHERE cd.collection_id=?
  `).all(collectionId);
});

ipcMain.handle('add-docs-to-collection', (_, { collectionId, docIds }) => {
  const insert = db.prepare('INSERT OR IGNORE INTO collection_documents (collection_id, document_id) VALUES (?, ?)');
  const tx = db.transaction((ids) => {
    for (const docId of ids) insert.run(collectionId, docId);
  });
  tx(docIds);
  return true;
});

ipcMain.handle('remove-doc-from-collection', (_, { collectionId, docId }) => {
  db.prepare('DELETE FROM collection_documents WHERE collection_id=? AND document_id=?')
    .run(collectionId, docId);
  return true;
});





# ./postcss.config.js
export default {
    plugins: {
      '@tailwindcss/postcss': {},
      autoprefixer: {},
    },
  };
  
# ./src/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document Organizer</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/main.jsx"></script>
</body>
</html>

# ./src/index.css
@import "tailwindcss";

html, body, #root {
height: 100%;
margin: 0;
font-family: 'Roboto', sans-serif;
background-color: #f5f7fa;
}

h1 {
margin-bottom: 20px;
}

button {
cursor: pointer;
}

.MuiTable-root th {
background-color: #f0f2f5;
font-weight: bold;
}

.MuiTableRow-root:hover {
background-color: #f9fafb;
}

.drag-over {
border: 2px dashed #736efe;
background-color: rgba(115, 110, 254, 0.05);

pointer-events: none;
}
.drag-over * {
pointer-events: auto;
}

.chip-container {
display: flex;
flex-wrap: wrap;
gap: 4px;
}

.chip-container .MuiChip-root {
margin: 2px;
}

.add-tag-input {
width: 80px;
margin-top: 2px;
}

.action-buttons button {
min-width: 30px;
margin-right: 2px;
}


# ./src/components/DocumentsTable.jsx
import React, { useState, useEffect } from 'react';
import FilePreviewModal from './FilePreviewModal.jsx';
import { EyeIcon, FolderIcon, TrashIcon, XMarkIcon } from '@heroicons/react/24/solid';

const CATEGORY_OPTIONS = ['Work', 'Personal', 'Finance', 'Legal', 'Health', 'Other'];

export default function DocumentsTable() {
  const [documents, setDocuments] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [previewFile, setPreviewFile] = useState(null);
  const [semanticQuery, setSemanticQuery] = useState('');
  const [semanticResults, setSemanticResults] = useState([]);
  const [selectedDocs, setSelectedDocs] = useState([]);

  const runSemanticSearch = async () => {
    if (!semanticQuery.trim()) return;
    const results = await window.electron.invoke('semantic-search', semanticQuery, 5);
    setSemanticResults(results);
    setSelectedDocs([]); // clear selection on new search
  };

  const refreshDocuments = async () => {
    const docs = await window.electron.invoke('get-documents');
    const checked = await Promise.all(
      docs.map(async (doc) => {
        const exists = await window.electron.invoke('file-exists', doc.path);
        return { ...doc, missing: !exists };
      })
    );
    setDocuments(checked);
  
    // ‚úÖ Generate embeddings for any docs that don't have them
    for (const doc of checked) {
      if (!doc.embedding) {
        await window.electron.invoke('generate-document-embedding', doc.id);
      }
    }
  };

  useEffect(() => {
    refreshDocuments();
    const listener = () => refreshDocuments();
    window.electron.on('documents-updated', listener);
    return () => {};
  }, []);

  const updateDocument = (id, data) => {
    window.electron.invoke('update-document', { id, ...data });
  };

  const deleteDocument = (id) => {
    if (confirm('Are you sure you want to delete this document from the database?')) {
      window.electron.invoke('delete-document', id);
    }
  };

  const deleteSelectedDocuments = async () => {
    if (selectedDocs.length === 0) return;
    if (!confirm(`Delete ${selectedDocs.length} selected documents?`)) return;
    for (const id of selectedDocs) {
      await window.electron.invoke('delete-document', id);
    }
    setSelectedDocs([]);
  };

  const viewFile = async (filePath, name) => {
    const fileData = await window.electron.invoke('read-file-content', filePath);
    setPreviewFile({ ...fileData, name });
  };
  
  const showInFinder = (filePath) => window.electron.invoke('show-in-finder', filePath);

  const handleTagAdd = (doc, e) => {
    if (e.key === 'Enter' && e.target.value.trim() !== '') {
      const newTags = doc.tags ? doc.tags.split(',').map(t => t.trim()) : [];
      newTags.push(e.target.value.trim());
      const tagStr = newTags.join(', ');
      updateDocument(doc.id, { tags: tagStr });
      e.target.value = '';
    }
  };

  const handleTagRemove = (doc, tag) => {
    const newTags = doc.tags
      .split(',')
      .map(t => t.trim())
      .filter(t => t !== tag)
      .join(', ');
    updateDocument(doc.id, { tags: newTags });
  };

  // ---------- Multi-Select ----------
  const toggleSelect = (docId) => {
    setSelectedDocs(prev => 
      prev.includes(docId) ? prev.filter(id => id !== docId) : [...prev, docId]
    );
  };

  const selectAll = () => {
    const ids = displayedDocs.map(doc => doc.id);
    setSelectedDocs(ids);
  };

  const clearSelection = () => setSelectedDocs([]);

  // ---------- Filtering ----------
  const filteredDocs = documents.filter(doc => {
    const query = searchQuery.toLowerCase();
    return (
      (doc.name || '').toLowerCase().includes(query) ||
      (doc.path || '').toLowerCase().includes(query) ||
      (doc.category || '').toLowerCase().includes(query) ||
      (doc.tags || '').toLowerCase().includes(query)
    );
  });

  const displayedDocs = semanticResults.length > 0 ? semanticResults : filteredDocs;

  const [showCollectionModal, setShowCollectionModal] = useState(false);
  const [collections, setCollections] = useState([]);
  const [selectedCollectionId, setSelectedCollectionId] = useState(null);

  // Fetch collections
  const refreshCollections = async () => {
    const cols = await window.electron.invoke('get-collections');
    setCollections(cols);
  };

  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-semibold text-gray-800 mb-2">Your Documents</h2>

      {/* Text search */}
      <input
        type="text"
        placeholder="Search by name, path, category, or tags..."
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        className="w-full p-3 border rounded-full shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400"
      />

      {/* Semantic search */}
      <div className="flex gap-2 my-4">
        <input
          type="text"
          placeholder="Ask in natural language..."
          value={semanticQuery}
          onChange={(e) => setSemanticQuery(e.target.value)}
          className="flex-1 p-3 border rounded-full shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-400"
        />
        <button
          onClick={runSemanticSearch}
          className="px-4 py-2 bg-indigo-500 text-white rounded-full shadow hover:bg-indigo-600 transition"
        >
          üîç Semantic Search
        </button>
      </div>

      {semanticResults.length > 0 && (
        <div className="text-sm text-indigo-600 font-medium mb-2">
          Showing top {semanticResults.length} semantic matches for "{semanticQuery}"
          <button 
            onClick={() => setSemanticResults([])} 
            className="ml-2 text-red-500 hover:underline"
          >
            Clear
          </button>
        </div>
      )}

      {/* Bulk Action Toolbar */}
      {selectedDocs.length > 0 && (
        <div className="flex gap-2 mb-4 items-center">
          <span className="text-sm text-gray-600">
            {selectedDocs.length} selected
          </span>
          <button
            onClick={deleteSelectedDocuments}
            className="px-3 py-1 bg-red-500 text-white rounded-full hover:bg-red-600 transition"
          >
            üóë Delete Selected
          </button>
          <button
            onClick={() => { refreshCollections(); setShowCollectionModal(true); }}
            className="px-3 py-1 bg-green-500 text-white rounded-full hover:bg-green-600 transition"
          >
            ‚ûï Add to Collection
          </button>
          <button
            onClick={clearSelection}
            className="px-3 py-1 bg-gray-400 text-white rounded-full hover:bg-gray-500 transition"
          >
            ‚úñ Clear Selection
          </button>
        </div>
      )}

      <div className="overflow-x-auto rounded-2xl shadow-sm border border-gray-200">
        <table className="min-w-full border-collapse overflow-hidden rounded-2xl">
          <thead className="bg-gray-50 text-gray-700 text-sm">
            <tr>
              <th className="p-3 text-center">
                <input 
                  type="checkbox"
                  checked={selectedDocs.length === displayedDocs.length && displayedDocs.length > 0}
                  onChange={(e) => e.target.checked ? selectAll() : clearSelection()}
                />
              </th>
              <th className="p-3 text-left">File Name</th>
              <th className="p-3 text-left">Path</th>
              <th className="p-3 text-left">Category</th>
              <th className="p-3 text-left">Tags</th>
              {semanticResults.length > 0 && (
                <th className="p-3 text-left">Snippet</th>
              )}
              <th className="p-3 text-center">Missing?</th>
              <th className="p-3 text-center">Actions</th>
            </tr>
          </thead>
          <tbody>
            {displayedDocs.map((doc, idx) => (
              <tr
                key={doc.id}
                className={`border-t border-gray-100 hover:bg-gray-50 transition ${
                  idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'
                } ${doc.missing ? 'bg-red-50' : ''}`}
              >
                <td className="p-3 text-center">
                  <input
                    type="checkbox"
                    checked={selectedDocs.includes(doc.id)}
                    onChange={() => toggleSelect(doc.id)}
                  />
                </td>
                <td className="p-3 font-medium text-gray-800">{doc.name}</td>
                <td className="p-3 text-xs text-gray-500">{doc.path}</td>
                <td className="p-3">
                  <select
                    defaultValue={doc.category || 'Other'}
                    onChange={(e) => updateDocument(doc.id, { category: e.target.value })}
                    className="w-full border rounded-full p-1 px-2 text-sm shadow-sm bg-white focus:outline-none focus:ring-1 focus:ring-blue-400"
                  >
                    {CATEGORY_OPTIONS.map(cat => (
                      <option key={cat} value={cat}>{cat}</option>
                    ))}
                  </select>
                </td>
                <td className="p-3">
                  <div className="flex flex-wrap gap-1 mb-1">
                    {doc.tags && doc.tags.split(',').map(tag => (
                      <span
                        key={tag}
                        className="flex items-center bg-gradient-to-r from-blue-100 to-blue-200 text-blue-800 px-2 py-1 rounded-full text-xs shadow-sm hover:shadow transition"
                      >
                        {tag}
                        <XMarkIcon
                          className="w-4 h-4 ml-1 cursor-pointer hover:text-red-500 transition-transform hover:scale-110"
                          onClick={() => handleTagRemove(doc, tag)}
                        />
                      </span>
                    ))}
                  </div>
                  <input
                    type="text"
                    placeholder="Add tag..."
                    onKeyDown={(e) => handleTagAdd(doc, e)}
                    className="w-full border rounded-full p-1 px-2 text-xs shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-400"
                  />
                </td>
                {semanticResults.length > 0 && (
                  <td className="p-3 text-xs text-gray-600 max-w-xs truncate" title={doc.snippet}>
                    {doc.snippet && (
                      <span className="italic">
                        ‚Äú{doc.snippet}‚Äù
                      </span>
                    )}
                  </td>
                )}
                <td className="p-3 text-center font-semibold">
                  {doc.missing ? '‚ö†Ô∏è Missing' : 'No'}
                </td>
                <td className="p-3 text-center space-x-2">
                  <button 
                    onClick={() => viewFile(doc.path, doc.name)}
                    className="p-2 bg-blue-500 text-white rounded-full shadow hover:bg-blue-600 
                                transition-transform hover:scale-110 hover:rotate-3 hover:shadow-lg"
                    title="Preview File"
                  >
                    <EyeIcon className="w-4 h-4" />
                  </button>
                  <button 
                    onClick={() => showInFinder(doc.path)}
                    className="p-2 bg-gray-500 text-white rounded-full hover:bg-gray-600 transition"
                    title="Show in Finder"
                  >
                    <FolderIcon className="w-4 h-4" />
                  </button>
                  <button 
                    onClick={() => deleteDocument(doc.id)}
                    className="p-2 bg-red-500 text-white rounded-full hover:bg-red-600 transition"
                    title="Delete Document"
                  >
                    <TrashIcon className="w-4 h-4" />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* File Preview Modal */}
      <FilePreviewModal file={previewFile} onClose={() => setPreviewFile(null)} />

      {showCollectionModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
          <div className="bg-white rounded-2xl p-6 w-full max-w-md space-y-4 shadow-lg">
            <h2 className="text-xl font-semibold">Add to Collection</h2>

            {collections.length === 0 ? (
              <p className="text-gray-500">No collections yet. Create one in the Collections tab.</p>
            ) : (
              <select
                value={selectedCollectionId || ''}
                onChange={(e) => setSelectedCollectionId(Number(e.target.value))}
                className="w-full border rounded-lg p-2"
              >
                <option value="" disabled>Select a collection</option>
                {collections.map(col => (
                  <option key={col.id} value={col.id}>{col.name}</option>
                ))}
              </select>
            )}

            <div className="flex justify-end gap-2">
              <button
                onClick={() => setShowCollectionModal(false)}
                className="px-4 py-2 bg-gray-300 rounded-full hover:bg-gray-400"
              >
                Cancel
              </button>
              <button
                disabled={!selectedCollectionId}
                onClick={async () => {
                  await window.electron.invoke('add-docs-to-collection', {
                    collectionId: selectedCollectionId,
                    docIds: selectedDocs
                  });
                  setShowCollectionModal(false);
                  clearSelection();
                  alert('Documents added to collection!');
                }}
                className="px-4 py-2 bg-blue-500 text-white rounded-full hover:bg-blue-600 disabled:bg-gray-400"
              >
                Add
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

# ./src/components/Collections.jsx
import { useEffect, useState } from 'react';

export default function Collections({ onOpenCollection }) {
  const [collections, setCollections] = useState([]);
  const [name, setName] = useState('');

  const refresh = async () => {
    const data = await window.electron.invoke('get-collections');
    setCollections(data);
  };

  const createCollection = async () => {
    if (!name.trim()) return;
    await window.electron.invoke('create-collection', { name });
    setName('');
    refresh();
  };

  const deleteCollection = async (id) => {
    if (confirm('Delete this collection?')) {
      await window.electron.invoke('delete-collection', id);
      refresh();
    }
  };

  useEffect(() => { refresh(); }, []);

  return (
    <div className="space-y-4 p-4">
      <h2 className="text-2xl font-semibold">Collections</h2>

      {/* Create Collection */}
      <div className="flex gap-2">
        <input 
          value={name} 
          onChange={(e) => setName(e.target.value)}
          placeholder="New collection name"
          className="border rounded-full p-2 flex-1"
        />
        <button onClick={createCollection} className="bg-green-500 text-white px-4 rounded-full">
          ‚ûï Add
        </button>
      </div>

      {/* List of collections */}
      <ul className="space-y-2">
        {collections.map(col => (
          <li 
            key={col.id} 
            className="flex justify-between items-center bg-gray-100 p-2 rounded-lg cursor-pointer hover:bg-gray-200"
            onClick={() => onOpenCollection(col)}
          >
            <span>{col.name}</span>
            <button 
              onClick={(e) => { e.stopPropagation(); deleteCollection(col.id); }} 
              className="text-red-500 hover:text-red-700"
            >
              ‚úñ
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

# ./src/components/CollectionView.jsx
import { useEffect, useState } from 'react';

export default function CollectionView({ collection, onBack }) {
  const [docs, setDocs] = useState([]);

  const refreshDocs = async () => {
    const data = await window.electron.invoke('get-collection-docs', collection.id);
    setDocs(data);
  };

  const removeDoc = async (docId) => {
    await window.electron.invoke('remove-doc-from-collection', { collectionId: collection.id, docId });
    refreshDocs();
  };

  useEffect(() => { refreshDocs(); }, [collection]);

  return (
    <div className="p-4 space-y-4">
      <button onClick={onBack} className="text-blue-500 hover:underline">‚¨Ö Back to Collections</button>
      <h2 className="text-2xl font-semibold">{collection.name}</h2>

      <ul className="divide-y divide-gray-200">
        {docs.map(doc => (
          <li key={doc.id} className="flex justify-between items-center py-2">
            <span>{doc.name}</span>
            <button 
              onClick={() => removeDoc(doc.id)}
              className="text-red-500 hover:text-red-700"
            >
              Remove
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

# ./src/components/FilePreviewModal.jsx
import React from 'react';

export default function FilePreviewModal({ file, onClose }) {
  if (!file) return null;

  const { type, content, name } = file;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white rounded-2xl shadow-lg max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
        
        {/* Header */}
        <div className="flex justify-between items-center p-4 border-b">
          <h2 className="text-lg font-semibold">{name} Preview</h2>
          <button 
            onClick={onClose} 
            className="text-gray-500 hover:text-gray-800 transition text-2xl"
          >
            √ó
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-auto p-4 bg-gray-50">
          {type === 'text' && (
            <pre className="whitespace-pre-wrap text-sm font-mono">{content}</pre>
          )}

          {type === 'image' && (
            <img src={content} alt="Preview" className="max-h-[70vh] mx-auto" />
          )}

          {type === 'pdf' && (
            <iframe src={content} className="w-full h-[70vh]" title="PDF Preview" />
          )}

          {type === 'unsupported' && (
            <p className="text-gray-500 text-center mt-10">
              ‚ö†Ô∏è This file type is not supported for preview.
            </p>
          )}

          {type === 'error' && (
            <p className="text-red-500 text-center mt-10">
              ‚ùå Could not load file content.
            </p>
          )}
        </div>
      </div>
    </div>
  );
}

# ./src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';


ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

# ./src/App.jsx
import { useEffect, useState } from 'react';
import DocumentsTable from './components/DocumentsTable.jsx';
import Collections from './components/Collections.jsx';
import CollectionView from './components/CollectionView.jsx';

function App() {

  const [view, setView] = useState('docs');
  const [selectedCollection, setSelectedCollection] = useState(null);

  const addDocumentsFromFiles = async () => {
    const newDocs = await window.electron.invoke('pick-and-add-documents');
    if (!newDocs || newDocs.length === 0) return;
  
    for (const doc of newDocs) {
      // Generate embeddings for each new doc
      await window.electron.invoke('generate-document-embedding', doc.id);
    }
  };

  const pickDirectory = async () => {
    const addedDocs = await window.electron.invoke('pick-directory');
    if (!addedDocs) return;
  
    // ‚úÖ Generate embeddings for each new doc
    for (const doc of addedDocs) {
      await window.electron.invoke('generate-document-embedding', doc.id);
    }
  };

  const checkMissingFiles = async () => {
    const removedCount = await window.electron.invoke('check-missing-files');
    alert(`Removed ${removedCount} missing files from database.`);
  };

  const exportDB = () => window.electron.invoke('export-db');
  const importDB = () => window.electron.invoke('import-db');

  const handleDrop = async (e) => {
    e.preventDefault();
    const files = [...e.dataTransfer.files].map(f => f.path);
    await window.electron.invoke('add-dropped-files', files);
  };

  return (
    <div
      className="min-h-screen bg-gray-100 flex justify-center p-6 font-sans"
      onDrop={handleDrop}
      onDragOver={(e) => e.preventDefault()}
    >
      <div className="w-full max-w-7xl space-y-6">

        {/* Header */}
        <div className="bg-white shadow-md rounded-2xl p-8 flex flex-col items-center">
          <h1 className="text-4xl font-semibold text-gray-800 mb-1 flex items-center gap-2">
            üìÇ Document Organizer
          </h1>
          <p className="text-gray-500 text-sm">Organize, tag, and manage your files effortlessly</p>
        </div>

        {/* Action Buttons */}
        <div className="bg-white shadow rounded-xl p-4 flex flex-wrap justify-center gap-3">
          <button onClick={addDocumentsFromFiles} className="px-4 py-2 bg-blue-500 text-white rounded-full shadow hover:bg-blue-600 transition">
            üìÑ Add Files
          </button>
          <button onClick={pickDirectory} className="px-4 py-2 bg-green-500 text-white rounded-full shadow hover:bg-green-600 transition">
            üìÅ Add Directory
          </button>
          <button onClick={checkMissingFiles} className="px-4 py-2 bg-yellow-400 text-white rounded-full shadow hover:bg-yellow-500 transition">
            üßπ Remove Missing Files
          </button>
          <button onClick={exportDB} className="px-4 py-2 bg-indigo-500 text-white rounded-full shadow hover:bg-indigo-600 transition">
            üíæ Export DB
          </button>
          <button onClick={importDB} className="px-4 py-2 bg-purple-500 text-white rounded-full shadow hover:bg-purple-600 transition">
            üì• Import DB
          </button>
        </div>

        {/* Table */}
        <div className="w-full max-w-7xl space-y-6">

          {/* Navigation */}
          <div className="flex gap-4 mb-4">
            <button onClick={() => setView('docs')} className={`px-4 py-2 rounded-full ${view==='docs' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>
              üìÑ Documents
            </button>
            <button onClick={() => setView('collections')} className={`px-4 py-2 rounded-full ${view==='collections' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>
              üìö Collections
            </button>
          </div>

          {/* Views */}
          {view === 'docs' && <DocumentsTable />}
          {view === 'collections' && !selectedCollection && (
            <Collections onOpenCollection={(col) => setSelectedCollection(col)} />
          )}
          {selectedCollection && (
            <CollectionView 
              collection={selectedCollection} 
              onBack={() => setSelectedCollection(null)} 
            />
          )}
        </div>
      </div>
    </div>
  );
}

export default App;

