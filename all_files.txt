
# ./vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  root: './src',
  base: './',
  build: {
    outDir: '../dist',
  },
});

# ./files.sh

echo "" > all_files.txt

find . \
  -type f \
  ! -path "*/node_modules/*" \
  ! -path "*/.git/*" \
  ! -path "*/package-lock.json" \
  ! -path "*/database.sqlite" \
  ! -path "*/all_files.txt" \
  ! -path "*/next_steps.txt" \
  ! -path "*/clipboard.txt" \
  | while read file; do
      echo "# ${file#/path/to/root/}"
      echo "# ${file#/path/to/root/}" >> all_files.txt
      cat "$file" >> all_files.txt
      echo "" >> all_files.txt
    done

# ./.gitignore
node_modules

# ./package.json
{
  "name": "document-organizer",
  "version": "0.0.1",
  "main": "electron/main.js",
  "type": "module",
  "scripts": {
    "dev:react": "vite",
    "dev:electron": "wait-on tcp:5173 && electron .",
    "start": "concurrently \"npm run dev:react\" \"npm run dev:electron\"",
    "postinstall": "electron-rebuild"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.7",
    "@heroicons/react": "^2.2.0",
    "better-sqlite3": "^9.6.0",
    "electron": "^29.0.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.0.0",
    "autoprefixer": "^10.4.21",
    "concurrently": "^8.0.0",
    "electron-rebuild": "^3.2.9",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.11",
    "vite": "^5.0.0",
    "wait-on": "^7.0.0"
  }
}

# ./electron/preload.js
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electron', {
  invoke: (channel, data) => ipcRenderer.invoke(channel, data),
  on: (channel, func) => ipcRenderer.on(channel, (event, ...args) => func(...args))
});

# ./electron/db.js
// electron/db.js
import Database from 'better-sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const dbPath = path.join(__dirname, '..', 'database.sqlite');
const db = new Database(dbPath);

// Create table with new columns for phase 3
db.prepare(`
  CREATE TABLE IF NOT EXISTS documents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    path TEXT UNIQUE,
    size INTEGER,
    lastModified TEXT,
    category TEXT DEFAULT '',
    tags TEXT DEFAULT ''
  )
`).run();

// Migration in case old DB exists
try {
  db.prepare('ALTER TABLE documents ADD COLUMN category TEXT DEFAULT ""').run();
} catch {}
try {
  db.prepare('ALTER TABLE documents ADD COLUMN tags TEXT DEFAULT ""').run();
} catch {}

db.prepare('CREATE INDEX IF NOT EXISTS idx_documents_path ON documents(path)').run();
db.prepare('CREATE INDEX IF NOT EXISTS idx_documents_lastModified ON documents(lastModified)').run();

export default db;

# ./electron/main.js
import { app, BrowserWindow, ipcMain, dialog, shell } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import db from './db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 900,
    height: 650,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  mainWindow.loadURL('http://localhost:5173');
}

// Utility: File metadata
function getFileMetadata(filePath) {
  try {
    const stats = fs.statSync(filePath);
    return { size: stats.size, lastModified: stats.mtime.toISOString() };
  } catch {
    return { size: null, lastModified: null };
  }
}

// Utility: Recursive directory scan
function getAllFiles(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files = files.concat(getAllFiles(fullPath));
    } else {
      files.push(fullPath);
    }
  }
  return files;
}

app.whenReady().then(() => {
  createWindow();
});

//
// IPC HANDLERS
//

// Fetch all documents
ipcMain.handle('get-documents', async () => {
  return db.prepare('SELECT * FROM documents').all();
});

// Update category/tags
ipcMain.handle('update-document', async (_, { id, category, tags }) => {
  if (category !== undefined) {
    db.prepare('UPDATE documents SET category = ? WHERE id = ?').run(category, id);
  }
  if (tags !== undefined) {
    db.prepare('UPDATE documents SET tags = ? WHERE id = ?').run(tags, id);
  }
  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
});

ipcMain.handle('delete-document', (event, docId) => {
  db.prepare('DELETE FROM documents WHERE id = ?').run(docId);
  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return true;
});

ipcMain.handle('pick-and-add-document', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({ properties: ['openFile'] });
  if (canceled || filePaths.length === 0) return null;

  const filePath = filePaths[0];
  const fileName = path.basename(filePath);

  // Prevent duplicates
  const exists = db.prepare('SELECT 1 FROM documents WHERE path = ?').get(filePath);
  if (exists) return { duplicate: true, name: fileName, path: filePath };

  const meta = getFileMetadata(filePath);
  db.prepare('INSERT INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)')
    .run(fileName, filePath, meta.size, meta.lastModified);

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs[updatedDocs.length - 1];
});

ipcMain.handle('pick-directory', async () => {
  const result = await dialog.showOpenDialog({ properties: ['openDirectory'] });
  if (result.canceled || result.filePaths.length === 0) return;

  const dirPath = result.filePaths[0];
  const filePaths = getAllFiles(dirPath);

  const insert = db.prepare(
    'INSERT OR IGNORE INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)'
  );
  for (const filePath of filePaths) {
    const meta = getFileMetadata(filePath);
    insert.run(path.basename(filePath), filePath, meta.size, meta.lastModified);
  }

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs;
});

// Drag & drop handler
ipcMain.handle('add-dropped-files', (event, filePaths) => {
  const insert = db.prepare(
    'INSERT OR IGNORE INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)'
  );

  function processPath(p) {
    const stats = fs.statSync(p);
    if (stats.isDirectory()) {
      const entries = fs.readdirSync(p);
      for (const entry of entries) {
        processPath(path.join(p, entry));
      }
    } else {
      const meta = getFileMetadata(p);
      insert.run(path.basename(p), p, meta.size, meta.lastModified);
    }
  }

  filePaths.forEach(processPath);

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs;
});


ipcMain.handle('show-in-finder', (_, filePath) => shell.showItemInFolder(filePath));
ipcMain.handle('open-file', async (_, filePath) => shell.openPath(filePath));

ipcMain.handle('check-missing-files', () => {
  const docs = db.prepare('SELECT * FROM documents').all();
  const missing = [];

  for (const doc of docs) {
    if (!fs.existsSync(doc.path)) {
      missing.push(doc.id);
    }
  }

  if (missing.length > 0) {
    db.prepare(`DELETE FROM documents WHERE id IN (${missing.join(',')})`).run();
  }

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);

  return missing.length;
});

// Update tags/category
ipcMain.handle('update-doc-metadata', (event, { id, category, tags }) => {
  db.prepare('UPDATE documents SET category=?, tags=? WHERE id=?').run(category, tags, id);
  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return true;
});

// Export DB
ipcMain.handle('export-db', async () => {
  const { filePath } = await dialog.showSaveDialog({
    title: 'Export Database',
    defaultPath: 'documents-backup.sqlite',
    filters: [{ name: 'SQLite DB', extensions: ['sqlite'] }]
  });

  if (!filePath) return false;
  fs.copyFileSync(path.join(__dirname, '..', 'database.sqlite'), filePath);
  return true;
});

// Import DB
ipcMain.handle('import-db', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [{ name: 'SQLite DB', extensions: ['sqlite'] }]
  });

  if (canceled || filePaths.length === 0) return false;

  const importPath = filePaths[0];
  fs.copyFileSync(importPath, path.join(__dirname, '..', 'database.sqlite'));

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return true;
});

# ./src/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document Organizer</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/main.jsx"></script>
</body>
</html>

# ./src/index.css
html, body, #root {
height: 100%;
margin: 0;
font-family: 'Roboto', sans-serif;
background-color: #f5f7fa;
}

h1 {
margin-bottom: 20px;
}

button {
cursor: pointer;
}

.MuiTable-root th {
background-color: #f0f2f5;
font-weight: bold;
}

.MuiTableRow-root:hover {
background-color: #f9fafb;
}

.drag-over {
border: 2px dashed #736efe;
background-color: rgba(115, 110, 254, 0.05);

pointer-events: none;
}
.drag-over * {
pointer-events: auto;
}

.chip-container {
display: flex;
flex-wrap: wrap;
gap: 4px;
}

.chip-container .MuiChip-root {
margin: 2px;
}

.add-tag-input {
width: 80px;
margin-top: 2px;
}

.action-buttons button {
min-width: 30px;
margin-right: 2px;
}

@tailwind base;
@tailwind components;
@tailwind utilities;

# ./src/components/DocumentsTable.jsx
import React, { useState, useEffect } from 'react';
import { XMarkIcon } from '@heroicons/react/24/solid';

const CATEGORY_OPTIONS = [
  'Work', 'Personal', 'Finance', 'Legal', 'Health', 'Other'
];

export default function DocumentsTable() {
  const [documents, setDocuments] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');

  useEffect(() => {
    window.electron.ipcRenderer.invoke('get-documents').then(setDocuments);

    window.electron.ipcRenderer.on('documents-updated', (_, updatedDocs) => {
      setDocuments(updatedDocs);
    });

    return () => {
      window.electron.ipcRenderer.removeAllListeners('documents-updated');
    };
  }, []);

  const updateDocument = (id, data) => {
    window.electron.ipcRenderer.invoke('update-document', { id, ...data });
  };

  const handleTagAdd = (doc, e) => {
    if (e.key === 'Enter' && e.target.value.trim() !== '') {
      const newTags = doc.tags ? doc.tags.split(',').map(t => t.trim()) : [];
      newTags.push(e.target.value.trim());
      const tagStr = newTags.join(', ');
      updateDocument(doc.id, { tags: tagStr });
      e.target.value = '';
    }
  };

  const handleTagRemove = (doc, tag) => {
    const newTags = doc.tags
      .split(',')
      .map(t => t.trim())
      .filter(t => t !== tag)
      .join(', ');
    updateDocument(doc.id, { tags: newTags });
  };

  const filteredDocs = documents.filter(doc => {
    const query = searchQuery.toLowerCase();
    return (
      doc.file_name.toLowerCase().includes(query) ||
      doc.category.toLowerCase().includes(query) ||
      (doc.tags && doc.tags.toLowerCase().includes(query))
    );
  });

  return (
    <div className="p-6">
      <h2 className="text-2xl font-bold mb-4">Document Organizer</h2>

      <input
        type="text"
        placeholder="Search by name, category, or tags..."
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        className="w-full p-2 border rounded mb-4"
      />

      <div className="overflow-x-auto">
        <table className="min-w-full border border-gray-300">
          <thead className="bg-gray-100">
            <tr>
              <th className="p-2 border">File Name</th>
              <th className="p-2 border">Path</th>
              <th className="p-2 border">Category</th>
              <th className="p-2 border">Tags</th>
              <th className="p-2 border">Missing?</th>
            </tr>
          </thead>
          <tbody>
            {filteredDocs.map(doc => (
              <tr
                key={doc.id}
                className={`border-b ${doc.missing ? 'bg-red-100' : 'bg-white'}`}
              >
                <td className="p-2 border">{doc.file_name}</td>
                <td className="p-2 border text-xs">{doc.file_path}</td>
                <td className="p-2 border">
                  <select
                    defaultValue={doc.category || 'Other'}
                    onChange={(e) => updateDocument(doc.id, { category: e.target.value })}
                    className="w-full border rounded p-1"
                  >
                    {CATEGORY_OPTIONS.map(cat => (
                      <option key={cat} value={cat}>{cat}</option>
                    ))}
                  </select>
                </td>
                <td className="p-2 border">
                  <div className="flex flex-wrap gap-1 mb-1">
                    {doc.tags && doc.tags.split(',').map(tag => (
                      <span
                        key={tag}
                        className="flex items-center bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-xs"
                      >
                        {tag}
                        <XMarkIcon
                          className="w-4 h-4 ml-1 cursor-pointer"
                          onClick={() => handleTagRemove(doc, tag)}
                        />
                      </span>
                    ))}
                  </div>
                  <input
                    type="text"
                    placeholder="Add tag..."
                    onKeyDown={(e) => handleTagAdd(doc, e)}
                    className="w-full border rounded p-1 text-xs"
                  />
                </td>
                <td className="p-2 border text-center">{doc.missing ? 'Yes' : 'No'}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}

# ./src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

# ./src/App.jsx
import { useState, useEffect } from 'react';

function App() {
  const [documents, setDocuments] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');

  const fetchDocuments = async () => {
    const docs = await window.electron.invoke('get-documents');
    setDocuments(docs || []);
  };

  const addDocumentFromFile = async () => {
    const newDoc = await window.electron.invoke('pick-and-add-document');
    if (!newDoc) return;
    if (newDoc.duplicate) alert(`‚ö† ${newDoc.name} is already in the database.`);
  };

  const pickDirectory = async () => {
    await window.electron.invoke('pick-directory');
  };

  const showInFinder = (filePath) => window.electron.invoke('show-in-finder', filePath);
  const openFile = (filePath) => window.electron.invoke('open-file', filePath);
  const deleteDocument = (id) => window.electron.invoke('delete-document', id);

  const checkMissingFiles = async () => {
    const removedCount = await window.electron.invoke('check-missing-files');
    alert(`Removed ${removedCount} missing files from database.`);
  };

  const exportDB = () => window.electron.invoke('export-db');
  const importDB = () => window.electron.invoke('import-db');

  const updateMetadata = (id, category, tags) => {
    window.electron.invoke('update-doc-metadata', { id, category, tags });
  };

  useEffect(() => {
    fetchDocuments();
    window.electron.on('documents-updated', (updatedDocs) => {
      setDocuments(updatedDocs || []);
    });
  }, []);

  const filteredDocs = documents.filter(
    (doc) =>
      doc.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      doc.path.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (doc.tags || '').toLowerCase().includes(searchTerm.toLowerCase()) ||
      (doc.category || '').toLowerCase().includes(searchTerm.toLowerCase())
  );

  const formatSize = (size) => {
    if (!size) return '-';
    if (size < 1024) return `${size} B`;
    if (size < 1024 * 1024) return `${(size / 1024).toFixed(1)} KB`;
    return `${(size / (1024 * 1024)).toFixed(1)} MB`;
  };

  // Drag & drop
  const handleDrop = async (e) => {
    e.preventDefault();
    const files = [...e.dataTransfer.files].map(f => f.path);
    await window.electron.invoke('add-dropped-files', files);
  };

  return (
    <div
      style={{ padding: 20 }}
      onDrop={handleDrop}
      onDragOver={(e) => e.preventDefault()}
    >
      <h1>üìÇ Document Organizer</h1>

      <div style={{ marginBottom: 10 }}>
        <button onClick={addDocumentFromFile} style={{ marginRight: 10 }}>
          üìÑ Add File
        </button>
        <button onClick={pickDirectory} style={{ marginRight: 10 }}>
          üìÅ Add Directory (Recursive)
        </button>
        <button onClick={checkMissingFiles} style={{ marginRight: 10 }}>
          üßπ Remove Missing Files
        </button>
        <button onClick={exportDB} style={{ marginRight: 10 }}>
          üíæ Export DB
        </button>
        <button onClick={importDB}>
          üì• Import DB
        </button>
      </div>

      <input
        type="text"
        placeholder="üîç Search by name, path, tags, category..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        style={{ marginBottom: 20, padding: 5, width: 400 }}
      />

      <h2>Stored Documents ({filteredDocs.length}):</h2>
      {filteredDocs.length === 0 ? (
        <p>No matching documents.</p>
      ) : (
        <table border="1" cellPadding="5" style={{ borderCollapse: 'collapse' }}>
          <thead>
            <tr>
              <th>Name</th>
              <th>Path</th>
              <th>Size</th>
              <th>Last Modified</th>
              <th>Category</th>
              <th>Tags</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {filteredDocs.map((doc) => (
              <tr key={doc.id}>
                <td>{doc.name}</td>
                <td>{doc.path}</td>
                <td>{formatSize(doc.size)}</td>
                <td>{doc.lastModified || '-'}</td>
                <td>
                  <input
                    value={doc.category || ''}
                    onChange={(e) =>
                      updateMetadata(doc.id, e.target.value, doc.tags || '')
                    }
                    style={{ width: 80 }}
                  />
                </td>
                <td>
                  <input
                    value={doc.tags || ''}
                    onChange={(e) =>
                      updateMetadata(doc.id, doc.category || '', e.target.value)
                    }
                    style={{ width: 120 }}
                  />
                </td>
                <td>
                  <button onClick={() => showInFinder(doc.path)}>üîç</button>
                  <button onClick={() => openFile(doc.path)} style={{ marginLeft: 5 }}>‚ñ∂</button>
                  <button onClick={() => deleteDocument(doc.id)} style={{ marginLeft: 5 }}>üóë</button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default App;

