
# ./vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  root: './src',
  base: './',
  build: {
    outDir: '../dist',
  },
});

# ./files.sh
echo "" > all_files.txt
find . \
  -type f \
  ! -path "*/node_modules/*" \
  ! -path "*/.git/*" \
  ! -path "*/package-lock.json" \
  ! -path "*/database.sqlite" \
  ! -path "*/all_files.txt" \
  ! -path "*/next_steps.txt" \
  | while read file; do
      echo "# ${file#/path/to/root/}"
      echo "# ${file#/path/to/root/}" >> all_files.txt
      cat "$file" >> all_files.txt
      echo "" >> all_files.txt
    done
# ./.gitignore
node_modules

# ./package.json
{
  "name": "document-organizer",
  "version": "0.0.1",
  "main": "electron/main.js",
  "type": "module",
  "scripts": {
    "dev:react": "vite",
    "dev:electron": "wait-on tcp:5173 && electron .",
    "start": "concurrently \"npm run dev:react\" \"npm run dev:electron\"",
    "postinstall": "electron-rebuild"
  },
  "dependencies": {
    "better-sqlite3": "^9.6.0",
    "electron": "^29.0.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.0.0",
    "concurrently": "^8.0.0",
    "electron-rebuild": "^3.2.9",
    "vite": "^5.0.0",
    "wait-on": "^7.0.0"
  }
}

# ./electron/preload.js
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electron', {
  invoke: (channel, data) => ipcRenderer.invoke(channel, data),
  on: (channel, func) => ipcRenderer.on(channel, (event, ...args) => func(...args))
});

# ./electron/db.js
// electron/db.js
import Database from 'better-sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const dbPath = path.join(__dirname, '..', 'database.sqlite');
const db = new Database(dbPath);

// Create table + indexes
db.prepare(`
  CREATE TABLE IF NOT EXISTS documents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    path TEXT UNIQUE,
    size INTEGER,
    lastModified TEXT
  )
`).run();

db.prepare('CREATE INDEX IF NOT EXISTS idx_documents_path ON documents(path)').run();
db.prepare('CREATE INDEX IF NOT EXISTS idx_documents_lastModified ON documents(lastModified)').run();

export default db;

# ./electron/main.js
import { app, BrowserWindow, ipcMain, dialog, shell } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import db from './db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 900,
    height: 650,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  mainWindow.loadURL('http://localhost:5173');
}

// Utility: File metadata
function getFileMetadata(filePath) {
  try {
    const stats = fs.statSync(filePath);
    return { size: stats.size, lastModified: stats.mtime.toISOString() };
  } catch {
    return { size: null, lastModified: null };
  }
}

// Utility: Recursive directory scan
function getAllFiles(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files = files.concat(getAllFiles(fullPath));
    } else {
      files.push(fullPath);
    }
  }
  return files;
}

app.whenReady().then(() => {
  createWindow();
});

//
// IPC HANDLERS
//

ipcMain.handle('get-documents', () => db.prepare('SELECT * FROM documents').all());

ipcMain.handle('delete-document', (event, docId) => {
  db.prepare('DELETE FROM documents WHERE id = ?').run(docId);
  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return true;
});

ipcMain.handle('pick-and-add-document', async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({ properties: ['openFile'] });
  if (canceled || filePaths.length === 0) return null;

  const filePath = filePaths[0];
  const fileName = path.basename(filePath);

  // Prevent duplicates
  const exists = db.prepare('SELECT 1 FROM documents WHERE path = ?').get(filePath);
  if (exists) return { duplicate: true, name: fileName, path: filePath };

  const meta = getFileMetadata(filePath);
  db.prepare('INSERT INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)')
    .run(fileName, filePath, meta.size, meta.lastModified);

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs[updatedDocs.length - 1];
});

ipcMain.handle('pick-directory', async () => {
  const result = await dialog.showOpenDialog({ properties: ['openDirectory'] });
  if (result.canceled || result.filePaths.length === 0) return;

  const dirPath = result.filePaths[0];
  const filePaths = getAllFiles(dirPath);

  const insert = db.prepare(
    'INSERT OR IGNORE INTO documents (name, path, size, lastModified) VALUES (?, ?, ?, ?)'
  );
  for (const filePath of filePaths) {
    const meta = getFileMetadata(filePath);
    insert.run(path.basename(filePath), filePath, meta.size, meta.lastModified);
  }

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);
  return updatedDocs;
});

ipcMain.handle('show-in-finder', (_, filePath) => shell.showItemInFolder(filePath));
ipcMain.handle('open-file', async (_, filePath) => shell.openPath(filePath));

// ‚úÖ Missing files check
ipcMain.handle('check-missing-files', () => {
  const docs = db.prepare('SELECT * FROM documents').all();
  const missing = [];

  for (const doc of docs) {
    if (!fs.existsSync(doc.path)) {
      missing.push(doc.id);
    }
  }

  if (missing.length > 0) {
    db.prepare(`DELETE FROM documents WHERE id IN (${missing.join(',')})`).run();
  }

  const updatedDocs = db.prepare('SELECT * FROM documents').all();
  mainWindow.webContents.send('documents-updated', updatedDocs);

  return missing.length;
});

# ./src/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document Organizer</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/main.jsx"></script>
</body>
</html>

# ./src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

# ./src/App.jsx
import { useState, useEffect } from 'react';

function App() {
  const [documents, setDocuments] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');

  const fetchDocuments = async () => {
    const docs = await window.electron.invoke('get-documents');
    setDocuments(docs || []);
  };

  const addDocumentFromFile = async () => {
    const newDoc = await window.electron.invoke('pick-and-add-document');
    if (!newDoc) return;
    if (newDoc.duplicate) alert(`‚ö† ${newDoc.name} is already in the database.`);
  };

  const pickDirectory = async () => {
    await window.electron.invoke('pick-directory');
  };

  const showInFinder = (filePath) => {
    window.electron.invoke('show-in-finder', filePath);
  };

  const openFile = (filePath) => {
    window.electron.invoke('open-file', filePath);
  };

  const deleteDocument = (id) => {
    window.electron.invoke('delete-document', id);
  };

  const checkMissingFiles = async () => {
    const removedCount = await window.electron.invoke('check-missing-files');
    alert(`Removed ${removedCount} missing files from database.`);
  };

  useEffect(() => {
    fetchDocuments();
    window.electron.on('documents-updated', (updatedDocs) => {
      setDocuments(updatedDocs || []);
    });
  }, []);

  const filteredDocs = documents.filter(
    (doc) =>
      doc.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      doc.path.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const formatSize = (size) => {
    if (!size) return '-';
    if (size < 1024) return `${size} B`;
    if (size < 1024 * 1024) return `${(size / 1024).toFixed(1)} KB`;
    return `${(size / (1024 * 1024)).toFixed(1)} MB`;
  };

  const fileExists = (doc) => {
    try {
      return window.electron.fsExistsSync?.(doc.path); // Optional preload function
    } catch {
      return true; // assume exists if not checking locally
    }
  };

  return (
    <div style={{ padding: 20 }}>
      <h1>üìÇ Document Organizer</h1>

      <div style={{ marginBottom: 10 }}>
        <button onClick={addDocumentFromFile} style={{ marginRight: 10 }}>
          üìÑ Add File
        </button>
        <button onClick={pickDirectory} style={{ marginRight: 10 }}>
          üìÅ Add Directory (Recursive)
        </button>
        <button onClick={checkMissingFiles}>üßπ Remove Missing Files</button>
      </div>

      <input
        type="text"
        placeholder="üîç Search..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        style={{ marginBottom: 20, padding: 5, width: 300 }}
      />

      <h2>Stored Documents ({filteredDocs.length}):</h2>
      {filteredDocs.length === 0 ? (
        <p>No matching documents.</p>
      ) : (
        <table border="1" cellPadding="5" style={{ borderCollapse: 'collapse' }}>
          <thead>
            <tr>
              <th>Name</th>
              <th>Path</th>
              <th>Size</th>
              <th>Last Modified</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {filteredDocs.map((doc) => (
              <tr key={doc.id} style={{ color: doc.missing ? 'red' : 'black' }}>
                <td>{doc.name}</td>
                <td>{doc.path}</td>
                <td>{formatSize(doc.size)}</td>
                <td>{doc.lastModified || '-'}</td>
                <td>
                  <button onClick={() => showInFinder(doc.path)}>üîç</button>
                  <button onClick={() => openFile(doc.path)} style={{ marginLeft: 5 }}>‚ñ∂</button>
                  <button onClick={() => deleteDocument(doc.id)} style={{ marginLeft: 5 }}>üóë</button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default App;

